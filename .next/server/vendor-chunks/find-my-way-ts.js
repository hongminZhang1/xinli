"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/find-my-way-ts";
exports.ids = ["vendor-chunks/find-my-way-ts"];
exports.modules = {

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js":
/*!*************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/QueryString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * @since 1.0.0\n */ // Taken from https://github.com/anonrig/fast-querystring under MIT License\nconst plusRegex = /\\+/g;\nconst Empty = function() {};\nEmpty.prototype = /*#__PURE__*/ Object.create(null);\n/**\n * @category parsing\n * @since 1.0.0\n */ function parse(input) {\n    // Optimization: Use new Empty() instead of Object.create(null) for performance\n    // v8 has a better optimization for initializing functions compared to Object\n    const result = new Empty();\n    if (typeof input !== \"string\") {\n        return result;\n    }\n    const inputLength = input.length;\n    let key = \"\";\n    let value = \"\";\n    let startingIndex = -1;\n    let equalityIndex = -1;\n    let shouldDecodeKey = false;\n    let shouldDecodeValue = false;\n    let keyHasPlus = false;\n    let valueHasPlus = false;\n    let hasBothKeyValuePair = false;\n    let c = 0;\n    // Have a boundary of input.length + 1 to access last pair inside the loop.\n    for(let i = 0; i < inputLength + 1; i++){\n        c = i !== inputLength ? input.charCodeAt(i) : 38;\n        // Handle '&' and end of line to pass the current values to result\n        if (c === 38) {\n            hasBothKeyValuePair = equalityIndex > startingIndex;\n            // Optimization: Reuse equality index to store the end of key\n            if (!hasBothKeyValuePair) {\n                equalityIndex = i;\n            }\n            key = input.slice(startingIndex + 1, equalityIndex);\n            // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n            if (hasBothKeyValuePair || key.length > 0) {\n                // Optimization: Replace '+' with space\n                if (keyHasPlus) {\n                    key = key.replace(plusRegex, \" \");\n                }\n                // Optimization: Do not decode if it's not necessary.\n                if (shouldDecodeKey) {\n                    try {\n                        key = decodeURIComponent(key) || key;\n                    } catch  {}\n                }\n                if (hasBothKeyValuePair) {\n                    value = input.slice(equalityIndex + 1, i);\n                    if (valueHasPlus) {\n                        value = value.replace(plusRegex, \" \");\n                    }\n                    if (shouldDecodeValue) {\n                        try {\n                            value = decodeURIComponent(value) || value;\n                        } catch  {}\n                    }\n                }\n                const currentValue = result[key];\n                if (currentValue === undefined) {\n                    result[key] = value;\n                } else {\n                    // Optimization: value.pop is faster than Array.isArray(value)\n                    if (currentValue.pop) {\n                        currentValue.push(value);\n                    } else {\n                        result[key] = [\n                            currentValue,\n                            value\n                        ];\n                    }\n                }\n            }\n            // Reset reading key value pairs\n            value = \"\";\n            startingIndex = i;\n            equalityIndex = i;\n            shouldDecodeKey = false;\n            shouldDecodeValue = false;\n            keyHasPlus = false;\n            valueHasPlus = false;\n        } else if (c === 61) {\n            if (equalityIndex <= startingIndex) {\n                equalityIndex = i;\n            } else {\n                shouldDecodeValue = true;\n            }\n        } else if (c === 43) {\n            if (equalityIndex > startingIndex) {\n                valueHasPlus = true;\n            } else {\n                keyHasPlus = true;\n            }\n        } else if (c === 37) {\n            if (equalityIndex > startingIndex) {\n                shouldDecodeValue = true;\n            } else {\n                shouldDecodeKey = true;\n            }\n        }\n    }\n    return result;\n}\nfunction getAsPrimitive(value) {\n    const type = typeof value;\n    if (type === \"string\") {\n        // Length check is handled inside encodeString function\n        return encodeString(value);\n    } else if (type === \"bigint\" || type === \"boolean\") {\n        return \"\" + value;\n    } else if (type === \"number\" && Number.isFinite(value)) {\n        return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n    }\n    return \"\";\n}\n/**\n * @category encoding\n * @since 1.0.0\n */ function stringify(input) {\n    let result = \"\";\n    if (input === null || typeof input !== \"object\") {\n        return result;\n    }\n    const separator = \"&\";\n    const keys = Object.keys(input);\n    const keyLength = keys.length;\n    let valueLength = 0;\n    for(let i = 0; i < keyLength; i++){\n        const key = keys[i];\n        const value = input[key];\n        const encodedKey = encodeString(key) + \"=\";\n        if (i) {\n            result += separator;\n        }\n        if (Array.isArray(value)) {\n            valueLength = value.length;\n            for(let j = 0; j < valueLength; j++){\n                if (j) {\n                    result += separator;\n                }\n                // Optimization: Dividing into multiple lines improves the performance.\n                // Since v8 does not need to care about the '+' character if it was one-liner.\n                result += encodedKey;\n                result += getAsPrimitive(value[j]);\n            }\n        } else {\n            result += encodedKey;\n            result += getAsPrimitive(value);\n        }\n    }\n    return result;\n}\n// -----------------------------------------------------------------------------\n// This has been taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\nconst hexTable = /*#__PURE__*/ Array.from({\n    length: 256\n}, (_, i)=>\"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase());\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// biome-ignore format: the array should not be formatted\nconst noEscape = /*#__PURE__*/ new Int8Array([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    // 0 - 15\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    // 16 - 31\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    // 32 - 47\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    // 48 - 63\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    // 64 - 79\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    // 80 - 95\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    // 96 - 111\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    0 // 112 - 127\n]);\nfunction encodeString(str) {\n    const len = str.length;\n    if (len === 0) return \"\";\n    let out = \"\";\n    let lastPos = 0;\n    let i = 0;\n    outer: for(; i < len; i++){\n        let c = str.charCodeAt(i);\n        // ASCII\n        while(c < 0x80){\n            if (noEscape[c] !== 1) {\n                if (lastPos < i) out += str.slice(lastPos, i);\n                lastPos = i + 1;\n                out += hexTable[c];\n            }\n            if (++i === len) break outer;\n            c = str.charCodeAt(i);\n        }\n        if (lastPos < i) out += str.slice(lastPos, i);\n        // Multi-byte characters ...\n        if (c < 0x800) {\n            lastPos = i + 1;\n            out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];\n            continue;\n        }\n        if (c < 0xd800 || c >= 0xe000) {\n            lastPos = i + 1;\n            out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n            continue;\n        }\n        // Surrogate pair\n        ++i;\n        // This branch should never happen because all URLSearchParams entries\n        // should already be converted to USVString. But, included for\n        // completion's sake anyway.\n        if (i >= len) {\n            throw new Error(\"URI malformed\");\n        }\n        const c2 = str.charCodeAt(i) & 0x3ff;\n        lastPos = i + 1;\n        c = 0x10000 + ((c & 0x3ff) << 10 | c2);\n        out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n    }\n    if (lastPos === 0) return str;\n    if (lastPos < len) return out + str.slice(lastPos);\n    return out;\n} //# sourceMappingURL=QueryString.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vUXVlcnlTdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUNELDJFQUEyRTtBQUMzRSxNQUFNQSxZQUFZO0FBQ2xCLE1BQU1DLFFBQVEsWUFBYTtBQUMzQkEsTUFBTUMsU0FBUyxHQUFHLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0FBQzdDOzs7Q0FHQyxHQUNNLFNBQVNDLE1BQU1DLEtBQUs7SUFDekIsK0VBQStFO0lBQy9FLDZFQUE2RTtJQUM3RSxNQUFNQyxTQUFTLElBQUlOO0lBQ25CLElBQUksT0FBT0ssVUFBVSxVQUFVO1FBQzdCLE9BQU9DO0lBQ1Q7SUFDQSxNQUFNQyxjQUFjRixNQUFNRyxNQUFNO0lBQ2hDLElBQUlDLE1BQU07SUFDVixJQUFJQyxRQUFRO0lBQ1osSUFBSUMsZ0JBQWdCLENBQUM7SUFDckIsSUFBSUMsZ0JBQWdCLENBQUM7SUFDckIsSUFBSUMsa0JBQWtCO0lBQ3RCLElBQUlDLG9CQUFvQjtJQUN4QixJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLGVBQWU7SUFDbkIsSUFBSUMsc0JBQXNCO0lBQzFCLElBQUlDLElBQUk7SUFDUiwyRUFBMkU7SUFDM0UsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlaLGNBQWMsR0FBR1ksSUFBSztRQUN4Q0QsSUFBSUMsTUFBTVosY0FBY0YsTUFBTWUsVUFBVSxDQUFDRCxLQUFLO1FBQzlDLGtFQUFrRTtRQUNsRSxJQUFJRCxNQUFNLElBQUk7WUFDWkQsc0JBQXNCTCxnQkFBZ0JEO1lBQ3RDLDZEQUE2RDtZQUM3RCxJQUFJLENBQUNNLHFCQUFxQjtnQkFDeEJMLGdCQUFnQk87WUFDbEI7WUFDQVYsTUFBTUosTUFBTWdCLEtBQUssQ0FBQ1YsZ0JBQWdCLEdBQUdDO1lBQ3JDLDRGQUE0RjtZQUM1RixJQUFJSyx1QkFBdUJSLElBQUlELE1BQU0sR0FBRyxHQUFHO2dCQUN6Qyx1Q0FBdUM7Z0JBQ3ZDLElB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QzNDLDRCQUE0QjtRQUM1QixJQUFJRCxJQUFJLE9BQU87WUFDYmtDLFVBQVVqQyxJQUFJO1lBQ2RnQyxPQUFPVCxRQUFRLENBQUMsT0FBT3hCLEtBQUssRUFBRSxHQUFHd0IsUUFBUSxDQUFDLE9BQU94QixJQUFJLEtBQUs7WUFDMUQ7UUFDRjtRQUNBLElBQUlBLElBQUksVUFBVUEsS0FBSyxRQUFRO1lBQzdCa0MsVUFBVWpDLElBQUk7WUFDZGdDLE9BQU9ULFFBQVEsQ0FBQyxPQUFPeEIsS0FBSyxHQUFHLEdBQUd3QixRQUFRLENBQUMsT0FBT3hCLEtBQUssSUFBSSxLQUFLLEdBQUd3QixRQUFRLENBQUMsT0FBT3hCLElBQUksS0FBSztZQUM1RjtRQUNGO1FBQ0EsaUJBQWlCO1FBQ2pCLEVBQUVDO1FBQ0Ysc0VBQXNFO1FBQ3RFLDhEQUE4RDtRQUM5RCw0QkFBNEI7UUFDNUIsSUFBSUEsS0FBSytCLEtBQUs7WUFDWixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFDQSxNQUFNQyxLQUFLTixJQUFJN0IsVUFBVSxDQUFDRCxLQUFLO1FBQy9CaUMsVUFBVWpDLElBQUk7UUFDZEQsSUFBSSxVQUFXLEVBQUNBLElBQUksS0FBSSxLQUFNLEtBQUtxQyxFQUFDO1FBQ3BDSixPQUFPVCxRQUFRLENBQUMsT0FBT3hCLEtBQUssR0FBRyxHQUFHd0IsUUFBUSxDQUFDLE9BQU94QixLQUFLLEtBQUssS0FBSyxHQUFHd0IsUUFBUSxDQUFDLE9BQU94QixLQUFLLElBQUksS0FBSyxHQUFHd0IsUUFBUSxDQUFDLE9BQU94QixJQUFJLEtBQUs7SUFDaEk7SUFDQSxJQUFJa0MsWUFBWSxHQUFHLE9BQU9IO0lBQzFCLElBQUlHLFVBQVVGLEtBQUssT0FBT0MsTUFBTUYsSUFBSTVCLEtBQUssQ0FBQytCO0lBQzFDLE9BQU9EO0FBQ1QsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly94aW5saS8uL25vZGVfbW9kdWxlcy9maW5kLW15LXdheS10cy9kaXN0L2VzbS9RdWVyeVN0cmluZy5qcz9jYWViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Fub25yaWcvZmFzdC1xdWVyeXN0cmluZyB1bmRlciBNSVQgTGljZW5zZVxuY29uc3QgcGx1c1JlZ2V4ID0gL1xcKy9nO1xuY29uc3QgRW1wdHkgPSBmdW5jdGlvbiAoKSB7fTtcbkVtcHR5LnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgcGFyc2luZ1xuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAvLyBPcHRpbWl6YXRpb246IFVzZSBuZXcgRW1wdHkoKSBpbnN0ZWFkIG9mIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIHY4IGhhcyBhIGJldHRlciBvcHRpbWl6YXRpb24gZm9yIGluaXRpYWxpemluZyBmdW5jdGlvbnMgY29tcGFyZWQgdG8gT2JqZWN0XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgbGV0IGtleSA9IFwiXCI7XG4gIGxldCB2YWx1ZSA9IFwiXCI7XG4gIGxldCBzdGFydGluZ0luZGV4ID0gLTE7XG4gIGxldCBlcXVhbGl0eUluZGV4ID0gLTE7XG4gIGxldCBzaG91bGREZWNvZGVLZXkgPSBmYWxzZTtcbiAgbGV0IHNob3VsZERlY29kZVZhbHVlID0gZmFsc2U7XG4gIGxldCBrZXlIYXNQbHVzID0gZmFsc2U7XG4gIGxldCB2YWx1ZUhhc1BsdXMgPSBmYWxzZTtcbiAgbGV0IGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBmYWxzZTtcbiAgbGV0IGMgPSAwO1xuICAvLyBIYXZlIGEgYm91bmRhcnkgb2YgaW5wdXQubGVuZ3RoICsgMSB0byBhY2Nlc3MgbGFzdCBwYWlyIGluc2lkZSB0aGUgbG9vcC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aCArIDE7IGkrKykge1xuICAgIGMgPSBpICE9PSBpbnB1dExlbmd0aCA/IGlucHV0LmNoYXJDb2RlQXQoaSkgOiAzODtcbiAgICAvLyBIYW5kbGUgJyYnIGFuZCBlbmQgb2YgbGluZSB0byBwYXNzIHRoZSBjdXJyZW50IHZhbHVlcyB0byByZXN1bHRcbiAgICBpZiAoYyA9PT0gMzgpIHtcbiAgICAgIGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleDtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogUmV1c2UgZXF1YWxpdHkgaW5kZXggdG8gc3RvcmUgdGhlIGVuZCBvZiBrZXlcbiAgICAgIGlmICghaGFzQm90aEtleVZhbHVlUGFpcikge1xuICAgICAgICBlcXVhbGl0eUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGtleSA9IGlucHV0LnNsaWNlKHN0YXJ0aW5nSW5kZXggKyAxLCBlcXVhbGl0eUluZGV4KTtcbiAgICAgIC8vIEFkZCBrZXkvdmFsdWUgcGFpciBvbmx5IGlmIHRoZSByYW5nZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiAxOyBhLmsuYS4gY29udGFpbnMgYXQgbGVhc3QgXCI9XCJcbiAgICAgIGlmIChoYXNCb3RoS2V5VmFsdWVQYWlyIHx8IGtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogUmVwbGFjZSAnKycgd2l0aCBzcGFjZVxuICAgICAgICBpZiAoa2V5SGFzUGx1cykge1xuICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKHBsdXNSZWdleCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogRG8gbm90IGRlY29kZSBpZiBpdCdzIG5vdCBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChzaG91bGREZWNvZGVLZXkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSkgfHwga2V5O1xuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQm90aEtleVZhbHVlUGFpcikge1xuICAgICAgICAgIHZhbHVlID0gaW5wdXQuc2xpY2UoZXF1YWxpdHlJbmRleCArIDEsIGkpO1xuICAgICAgICAgIGlmICh2YWx1ZUhhc1BsdXMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShwbHVzUmVnZXgsIFwiIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZERlY29kZVZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgfHwgdmFsdWU7XG4gICAgICAgICAgICB9IGNhdGNoIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHJlc3VsdFtrZXldO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogdmFsdWUucG9wIGlzIGZhc3RlciB0aGFuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZS5wb3ApIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbY3VycmVudFZhbHVlLCB2YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZXNldCByZWFkaW5nIGtleSB2YWx1ZSBwYWlyc1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgc3RhcnRpbmdJbmRleCA9IGk7XG4gICAgICBlcXVhbGl0eUluZGV4ID0gaTtcbiAgICAgIHNob3VsZERlY29kZUtleSA9IGZhbHNlO1xuICAgICAgc2hvdWxkRGVjb2RlVmFsdWUgPSBmYWxzZTtcbiAgICAgIGtleUhhc1BsdXMgPSBmYWxzZTtcbiAgICAgIHZhbHVlSGFzUGx1cyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayAnPSdcbiAgICBlbHNlIGlmIChjID09PSA2MSkge1xuICAgICAgaWYgKGVxdWFsaXR5SW5kZXggPD0gc3RhcnRpbmdJbmRleCkge1xuICAgICAgICBlcXVhbGl0eUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIElmICc9JyBjaGFyYWN0ZXIgb2NjdXJzIGFnYWluLCB3ZSBzaG91bGQgZGVjb2RlIHRoZSBpbnB1dC5cbiAgICAgIGVsc2Uge1xuICAgICAgICBzaG91bGREZWNvZGVWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrICcrJywgYW5kIHJlbWVtYmVyIHRvIHJlcGxhY2UgaXQgd2l0aCBlbXB0eSBzcGFjZS5cbiAgICBlbHNlIGlmIChjID09PSA0Mykge1xuICAgICAgaWYgKGVxdWFsaXR5SW5kZXggPiBzdGFydGluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlSGFzUGx1cyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlIYXNQbHVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgJyUnIGNoYXJhY3RlciBmb3IgZW5jb2RpbmdcbiAgICBlbHNlIGlmIChjID09PSAzNykge1xuICAgICAgaWYgKGVxdWFsaXR5SW5kZXggPiBzdGFydGluZ0luZGV4KSB7XG4gICAgICAgIHNob3VsZERlY29kZVZhbHVlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3VsZERlY29kZUtleSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRBc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIExlbmd0aCBjaGVjayBpcyBoYW5kbGVkIGluc2lkZSBlbmNvZGVTdHJpbmcgZnVuY3Rpb25cbiAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImJpZ2ludFwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAxZTIxID8gXCJcIiArIHZhbHVlIDogZW5jb2RlU3RyaW5nKFwiXCIgKyB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG4vKipcbiAqIEBjYXRlZ29yeSBlbmNvZGluZ1xuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQpIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGlmIChpbnB1dCA9PT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9IFwiJlwiO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5wdXQpO1xuICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgbGV0IHZhbHVlTGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgIGNvbnN0IGVuY29kZWRLZXkgPSBlbmNvZGVTdHJpbmcoa2V5KSArIFwiPVwiO1xuICAgIGlmIChpKSB7XG4gICAgICByZXN1bHQgKz0gc2VwYXJhdG9yO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZUxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChqKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcHRpbWl6YXRpb246IERpdmlkaW5nIGludG8gbXVsdGlwbGUgbGluZXMgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlLlxuICAgICAgICAvLyBTaW5jZSB2OCBkb2VzIG5vdCBuZWVkIHRvIGNhcmUgYWJvdXQgdGhlICcrJyBjaGFyYWN0ZXIgaWYgaXQgd2FzIG9uZS1saW5lci5cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZWRLZXk7XG4gICAgICAgIHJlc3VsdCArPSBnZXRBc1ByaW1pdGl2ZSh2YWx1ZVtqXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBlbmNvZGVkS2V5O1xuICAgICAgcmVzdWx0ICs9IGdldEFzUHJpbWl0aXZlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGlzIGhhcyBiZWVuIHRha2VuIGZyb20gTm9kZS5qcyBwcm9qZWN0LlxuLy8gRnVsbCBpbXBsZW1lbnRhdGlvbiBjYW4gYmUgZm91bmQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYWluL2xpYi9pbnRlcm5hbC9xdWVyeXN0cmluZy5qc1xuY29uc3QgaGV4VGFibGUgPSAvKiNfX1BVUkVfXyovQXJyYXkuZnJvbSh7XG4gIGxlbmd0aDogMjU2XG59LCAoXywgaSkgPT4gXCIlXCIgKyAoKGkgPCAxNiA/IFwiMFwiIDogXCJcIikgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4vLyBUaGVzZSBjaGFyYWN0ZXJzIGRvIG5vdCBuZWVkIGVzY2FwaW5nIHdoZW4gZ2VuZXJhdGluZyBxdWVyeSBzdHJpbmdzOlxuLy8gISAtIC4gXyB+XG4vLyAnICggKSAqXG4vLyBkaWdpdHNcbi8vIGFscGhhICh1cHBlcmNhc2UpXG4vLyBhbHBoYSAobG93ZXJjYXNlKVxuLy8gYmlvbWUtaWdub3JlIGZvcm1hdDogdGhlIGFycmF5IHNob3VsZCBub3QgYmUgZm9ybWF0dGVkXG5jb25zdCBub0VzY2FwZSA9IC8qI19fUFVSRV9fKi9uZXcgSW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuLy8gMCAtIDE1XG4wLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuLy8gMTYgLSAzMVxuMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCxcbi8vIDMyIC0gNDdcbjEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsXG4vLyA0OCAtIDYzXG4wLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuLy8gNjQgLSA3OVxuMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMSxcbi8vIDgwIC0gOTVcbjAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4vLyA5NiAtIDExMVxuMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl0pO1xuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gXCJcIjtcbiAgbGV0IG91dCA9IFwiXCI7XG4gIGxldCBsYXN0UG9zID0gMDtcbiAgbGV0IGkgPSAwO1xuICBvdXRlcjogZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gQVNDSUlcbiAgICB3aGlsZSAoYyA8IDB4ODApIHtcbiAgICAgIGlmIChub0VzY2FwZVtjXSAhPT0gMSkge1xuICAgICAgICBpZiAobGFzdFBvcyA8IGkpIG91dCArPSBzdHIuc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlW2NdO1xuICAgICAgfVxuICAgICAgaWYgKCsraSA9PT0gbGVuKSBicmVhayBvdXRlcjtcbiAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgaWYgKGxhc3RQb3MgPCBpKSBvdXQgKz0gc3RyLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgIC8vIE11bHRpLWJ5dGUgY2hhcmFjdGVycyAuLi5cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICBvdXQgKz0gaGV4VGFibGVbMHhjMCB8IGMgPj4gNl0gKyBoZXhUYWJsZVsweDgwIHwgYyAmIDB4M2ZdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICBvdXQgKz0gaGV4VGFibGVbMHhlMCB8IGMgPj4gMTJdICsgaGV4VGFibGVbMHg4MCB8IGMgPj4gNiAmIDB4M2ZdICsgaGV4VGFibGVbMHg4MCB8IGMgJiAweDNmXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBTdXJyb2dhdGUgcGFpclxuICAgICsraTtcbiAgICAvLyBUaGlzIGJyYW5jaCBzaG91bGQgbmV2ZXIgaGFwcGVuIGJlY2F1c2UgYWxsIFVSTFNlYXJjaFBhcmFtcyBlbnRyaWVzXG4gICAgLy8gc2hvdWxkIGFscmVhZHkgYmUgY29udmVydGVkIHRvIFVTVlN0cmluZy4gQnV0LCBpbmNsdWRlZCBmb3JcbiAgICAvLyBjb21wbGV0aW9uJ3Mgc2FrZSBhbnl3YXkuXG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkkgbWFsZm9ybWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmY7XG4gICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgzZmYpIDw8IDEwIHwgYzIpO1xuICAgIG91dCArPSBoZXhUYWJsZVsweGYwIHwgYyA+PiAxOF0gKyBoZXhUYWJsZVsweDgwIHwgYyA+PiAxMiAmIDB4M2ZdICsgaGV4VGFibGVbMHg4MCB8IGMgPj4gNiAmIDB4M2ZdICsgaGV4VGFibGVbMHg4MCB8IGMgJiAweDNmXTtcbiAgfVxuICBpZiAobGFzdFBvcyA9PT0gMCkgcmV0dXJuIHN0cjtcbiAgaWYgKGxhc3RQb3MgPCBsZW4pIHJldHVybiBvdXQgKyBzdHIuc2xpY2UobGFzdFBvcyk7XG4gIHJldHVybiBvdXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWVyeVN0cmluZy5qcy5tYXAiXSwibmFtZXMiOlsicGx1c1JlZ2V4IiwiRW1wdHkiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJwYXJzZSIsImlucHV0IiwicmVzdWx0IiwiaW5wdXRMZW5ndGgiLCJsZW5ndGgiLCJrZXkiLCJ2YWx1ZSIsInN0YXJ0aW5nSW5kZXgiLCJlcXVhbGl0eUluZGV4Iiwic2hvdWxkRGVjb2RlS2V5Iiwic2hvdWxkRGVjb2RlVmFsdWUiLCJrZXlIYXNQbHVzIiwidmFsdWVIYXNQbHVzIiwiaGFzQm90aEtleVZhbHVlUGFpciIsImMiLCJpIiwiY2hhckNvZGVBdCIsInNsaWNlIiwicmVwbGFjZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImN1cnJlbnRWYWx1ZSIsInVuZGVmaW5lZCIsInBvcCIsInB1c2giLCJnZXRBc1ByaW1pdGl2ZSIsInR5cGUiLCJlbmNvZGVTdHJpbmciLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInN0cmluZ2lmeSIsInNlcGFyYXRvciIsImtleXMiLCJrZXlMZW5ndGgiLCJ2YWx1ZUxlbmd0aCIsImVuY29kZWRLZXkiLCJBcnJheSIsImlzQXJyYXkiLCJqIiwiaGV4VGFibGUiLCJmcm9tIiwiXyIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJub0VzY2FwZSIsIkludDhBcnJheSIsInN0ciIsImxlbiIsIm91dCIsImxhc3RQb3MiLCJvdXRlciIsIkVycm9yIiwiYzIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _internal_router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/router.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\");\n/**\n * @since 1.0.0\n */ \n/**\n * @since 1.0.0\n * @category constructors\n */ const make = _internal_router_js__WEBPACK_IMPORTED_MODULE_0__.make; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUNnRDtBQUNqRDs7O0NBR0MsR0FDTSxNQUFNQyxPQUFPRCxxREFBYSxDQUFDLENBQ2xDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3hpbmxpLy4vbm9kZV9tb2R1bGVzL2ZpbmQtbXktd2F5LXRzL2Rpc3QvZXNtL2luZGV4LmpzP2JiYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSBcIi4vaW50ZXJuYWwvcm91dGVyLmpzXCI7XG4vKipcbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IGNvbnN0cnVjdG9yc1xuICovXG5leHBvcnQgY29uc3QgbWFrZSA9IGludGVybmFsLm1ha2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiaW50ZXJuYWwiLCJtYWtlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/internal/router.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _QueryString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../QueryString.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\");\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//;\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/;\n/** @internal */ const make = (options = {})=>new RouterImpl(options);\nclass RouterImpl {\n    constructor(options = {}){\n        this.routes = [];\n        this.trees = {};\n        this.options = {\n            ignoreTrailingSlash: true,\n            ignoreDuplicateSlashes: true,\n            caseSensitive: false,\n            maxParamLength: 100,\n            ...options\n        };\n    }\n    on(method, path, handler) {\n        const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);\n        if (optionalParamMatch && optionalParamMatch.index !== undefined) {\n            assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, \"Optional Parameter needs to be the last parameter of the path\");\n            const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, \"$1$2\");\n            const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, \"$2\");\n            this.on(method, pathFull, handler);\n            this.on(method, pathOptional, handler);\n            return;\n        }\n        if (this.options.ignoreDuplicateSlashes) {\n            path = removeDuplicateSlashes(path);\n        }\n        if (this.options.ignoreTrailingSlash) {\n            path = trimLastSlash(path);\n        }\n        const methods = typeof method === \"string\" ? [\n            method\n        ] : method;\n        for (const method of methods){\n            this._on(method, path, handler);\n        }\n    }\n    all(path, handler) {\n        this.on(httpMethods, path, handler);\n    }\n    _on(method, path, handler) {\n        if (this.trees[method] === undefined) {\n            this.trees[method] = new StaticNode(\"/\");\n        }\n        let pattern = path;\n        if (pattern === \"*\" && this.trees[method].prefix.length !== 0) {\n            const currentRoot = this.trees[method];\n            this.trees[method] = new StaticNode(\"\");\n            this.trees[method].staticChildren[\"/\"] = currentRoot;\n        }\n        let parentNodePathIndex = this.trees[method].prefix.length;\n        let currentNode = this.trees[method];\n        const params = [];\n        for(let i = 0; i <= pattern.length; i++){\n            if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {\n                // It's a double colon\n                i++;\n                continue;\n            }\n            const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;\n            const isWildcardNode = pattern.charCodeAt(i) === 42;\n            if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {\n                let staticNodePath = pattern.slice(parentNodePathIndex, i);\n                if (!this.options.caseSensitive) {\n                    staticNodePath = staticNodePath.toLowerCase();\n                }\n                staticNodePath = staticNodePath.split(\"::\").join(\":\");\n                staticNodePath = staticNodePath.split(\"%\").join(\"%25\");\n                // add the static part of the route to the tree\n                currentNode = currentNode.createStaticChild(staticNodePath);\n            }\n            if (isParametricNode) {\n                let isRegexNode = false;\n                const regexps = [];\n                let lastParamStartIndex = i + 1;\n                for(let j = lastParamStartIndex;; j++){\n                    const charCode = pattern.charCodeAt(j);\n                    const isRegexParam = charCode === 40;\n                    const isStaticPart = charCode === 45 || charCode === 46;\n                    const isEndOfNode = charCode === 47 || j === pattern.length;\n                    if (isRegexParam || isStaticPart || isEndOfNode) {\n                        const paramName = pattern.slice(lastParamStartIndex, j);\n                        params.push(paramName);\n                        isRegexNode = isRegexNode || isRegexParam || isStaticPart;\n                        if (isRegexParam) {\n                            const endOfRegexIndex = getClosingParenthensePosition(pattern, j);\n                            const regexString = pattern.slice(j, endOfRegexIndex + 1);\n                            regexps.push(trimRegExpStartAndEnd(regexString));\n                            j = endOfRegexIndex + 1;\n                        } else {\n                            regexps.push(\"(.*?)\");\n                        }\n                        const staticPartStartIndex = j;\n                        for(; j < pattern.length; j++){\n                            const charCode = pattern.charCodeAt(j);\n                            if (charCode === 47) break;\n                            if (charCode === 58) {\n                                const nextCharCode = pattern.charCodeAt(j + 1);\n                                if (nextCharCode === 58) j++;\n                                else break;\n                            }\n                        }\n                        let staticPart = pattern.slice(staticPartStartIndex, j);\n                        if (staticPart) {\n                            staticPart = staticPart.split(\"::\").join(\":\");\n                            staticPart = staticPart.split(\"%\").join(\"%25\");\n                            regexps.push(escapeRegExp(staticPart));\n                        }\n                        lastParamStartIndex = j + 1;\n                        if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {\n                            const nodePattern = isRegexNode ? \"()\" + staticPart : staticPart;\n                            const nodePath = pattern.slice(i, j);\n                            pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);\n                            i += nodePattern.length;\n                            const regex = isRegexNode ? new RegExp(\"^\" + regexps.join(\"\") + \"$\") : undefined;\n                            currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);\n                            parentNodePathIndex = i + 1;\n                            break;\n                        }\n                    }\n                }\n            } else if (isWildcardNode) {\n                // add the wildcard parameter\n                params.push(\"*\");\n                currentNode = currentNode.createWildcardChild();\n                parentNodePathIndex = i + 1;\n                if (i !== pattern.length - 1) {\n                    throw new Error(\"Wildcard must be the last character in the route\");\n                }\n            }\n        }\n        if (!this.options.caseSensitive) {\n            pattern = pattern.toLowerCase();\n        }\n        if (pattern === \"*\") {\n            pattern = \"/*\";\n        }\n        for (const existRoute of this.routes){\n            if (existRoute.method === method && existRoute.pattern === pattern) {\n                throw new Error(`Method '${method}' already declared for route '${pattern}'`);\n            }\n        }\n        const route = {\n            method,\n            path,\n            pattern,\n            params,\n            handler\n        };\n        this.routes.push(route);\n        currentNode.addRoute(route);\n    }\n    has(method, path) {\n        const node = this.trees[method];\n        if (node === undefined) {\n            return false;\n        }\n        const staticNode = node.getStaticChild(path);\n        if (staticNode === undefined) {\n            return false;\n        }\n        return staticNode.isLeafNode;\n    }\n    find(method, path) {\n        let currentNode = this.trees[method];\n        if (currentNode === undefined) return undefined;\n        if (path.charCodeAt(0) !== 47) {\n            // 47 is '/'\n            path = path.replace(FULL_PATH_REGEXP, \"/\");\n        }\n        // This must be run before sanitizeUrl as the resulting function\n        // .sliceParameter must be constructed with same URL string used\n        // throughout the rest of this function.\n        if (this.options.ignoreDuplicateSlashes) {\n            path = removeDuplicateSlashes(path);\n        }\n        let sanitizedUrl;\n        let querystring;\n        let shouldDecodeParam;\n        try {\n            sanitizedUrl = safeDecodeURI(path);\n            path = sanitizedUrl.path;\n            querystring = sanitizedUrl.querystring;\n            shouldDecodeParam = sanitizedUrl.shouldDecodeParam;\n        } catch (error) {\n            return undefined;\n        }\n        if (this.options.ignoreTrailingSlash) {\n            path = trimLastSlash(path);\n        }\n        const originPath = path;\n        if (this.options.caseSensitive === false) {\n            path = path.toLowerCase();\n        }\n        const maxParamLength = this.options.maxParamLength;\n        let pathIndex = currentNode.prefix.length;\n        const params = [];\n        const pathLen = path.length;\n        const brothersNodesStack = [];\n        while(true){\n            if (pathIndex === pathLen && currentNode.isLeafNode) {\n                const handle = currentNode.handlerStorage?.find();\n                if (handle !== undefined) {\n                    return {\n                        handler: handle.handler,\n                        params: handle.createParams(params),\n                        searchParams: _QueryString_js__WEBPACK_IMPORTED_MODULE_0__.parse(querystring)\n                    };\n                }\n            }\n            let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);\n            if (node === undefined) {\n                if (brothersNodesStack.length === 0) {\n                    return undefined;\n                }\n                const brotherNodeState = brothersNodesStack.pop();\n                pathIndex = brotherNodeState.brotherPathIndex;\n                params.splice(brotherNodeState.paramsCount);\n                node = brotherNodeState.brotherNode;\n            }\n            currentNode = node;\n            // static route\n            if (currentNode._tag === \"StaticNode\") {\n                pathIndex += currentNode.prefix.length;\n                continue;\n            }\n            if (currentNode._tag === \"WildcardNode\") {\n                let param = originPath.slice(pathIndex);\n                if (shouldDecodeParam) {\n                    param = safeDecodeURIComponent(param);\n                }\n                params.push(param);\n                pathIndex = pathLen;\n                continue;\n            }\n            if (currentNode._tag === \"ParametricNode\") {\n                let paramEndIndex = originPath.indexOf(\"/\", pathIndex);\n                if (paramEndIndex === -1) {\n                    paramEndIndex = pathLen;\n                }\n                let param = originPath.slice(pathIndex, paramEndIndex);\n                if (shouldDecodeParam) {\n                    param = safeDecodeURIComponent(param);\n                }\n                if (currentNode.regex !== undefined) {\n                    const matchedParameters = currentNode.regex.exec(param);\n                    if (matchedParameters === null) continue;\n                    for(let i = 1; i < matchedParameters.length; i++){\n                        const matchedParam = matchedParameters[i];\n                        if (matchedParam.length > maxParamLength) {\n                            return undefined;\n                        }\n                        params.push(matchedParam);\n                    }\n                } else {\n                    if (param.length > maxParamLength) {\n                        return undefined;\n                    }\n                    params.push(param);\n                }\n                pathIndex = paramEndIndex;\n            }\n        }\n    }\n}\nclass HandlerStorage {\n    find() {\n        return this.unconstrainedHandler;\n    }\n    add(route) {\n        const handler = {\n            params: route.params,\n            handler: route.handler,\n            createParams: compileCreateParams(route.params)\n        };\n        this.handlers.push(handler);\n        this.unconstrainedHandler = this.handlers[0];\n    }\n    constructor(){\n        this.handlers = [];\n    }\n}\nclass NodeBase {\n    addRoute(route) {\n        if (this.routes === undefined) {\n            this.routes = [\n                route\n            ];\n        } else {\n            this.routes.push(route);\n        }\n        if (this.handlerStorage === undefined) {\n            this.handlerStorage = new HandlerStorage();\n        }\n        this.isLeafNode = true;\n        this.handlerStorage.add(route);\n    }\n    constructor(){\n        this.isLeafNode = false;\n    }\n}\nclass ParentNode extends NodeBase {\n    findStaticMatchingChild(path, pathIndex) {\n        const staticChild = this.staticChildren[path.charAt(pathIndex)];\n        if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n            return undefined;\n        }\n        return staticChild;\n    }\n    getStaticChild(path, pathIndex = 0) {\n        if (path.length === pathIndex) {\n            return this;\n        }\n        const staticChild = this.findStaticMatchingChild(path, pathIndex);\n        if (staticChild === undefined) {\n            return undefined;\n        }\n        return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);\n    }\n    createStaticChild(path) {\n        if (path.length === 0) {\n            return this;\n        }\n        let staticChild = this.staticChildren[path.charAt(0)];\n        if (staticChild) {\n            let i = 1;\n            for(; i < staticChild.prefix.length; i++){\n                if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n                    staticChild = staticChild.split(this, i);\n                    break;\n                }\n            }\n            return staticChild.createStaticChild(path.slice(i));\n        }\n        const label = path.charAt(0);\n        this.staticChildren[label] = new StaticNode(path);\n        return this.staticChildren[label];\n    }\n    constructor(...args){\n        super(...args);\n        this.staticChildren = {};\n    }\n}\nclass StaticNode extends ParentNode {\n    constructor(prefix){\n        super();\n        this._tag = \"StaticNode\";\n        this.parametricChildren = [];\n        this.setPrefix(prefix);\n    }\n    setPrefix(prefix) {\n        this.prefix = prefix;\n        if (prefix.length === 1) {\n            this.matchPrefix = (_path, _pathIndex)=>true;\n        } else {\n            const len = prefix.length;\n            this.matchPrefix = function(path, pathIndex) {\n                for(let i = 1; i < len; i++){\n                    if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        }\n    }\n    getParametricChild(regex) {\n        if (regex === undefined) {\n            return this.parametricChildren.find((child)=>child.isRegex === false);\n        }\n        const source = regex.source;\n        return this.parametricChildren.find((child)=>{\n            if (child.regex === undefined) {\n                return false;\n            }\n            return child.regex.source === source;\n        });\n    }\n    createParametricChild(regex, staticSuffix, nodePath) {\n        let child = this.getParametricChild(regex);\n        if (child !== undefined) {\n            child.nodePaths.add(nodePath);\n            return child;\n        }\n        child = new ParametricNode(regex, staticSuffix, nodePath);\n        this.parametricChildren.push(child);\n        this.parametricChildren.sort((child1, child2)=>{\n            if (!child1.isRegex) return 1;\n            if (!child2.isRegex) return -1;\n            if (child1.staticSuffix === undefined) return 1;\n            if (child2.staticSuffix === undefined) return -1;\n            if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;\n            if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;\n            return 0;\n        });\n        return child;\n    }\n    createWildcardChild() {\n        if (this.wildcardChild === undefined) {\n            this.wildcardChild = new WildcardNode();\n        }\n        return this.wildcardChild;\n    }\n    split(parentNode, length) {\n        const parentPrefix = this.prefix.slice(0, length);\n        const childPrefix = this.prefix.slice(length);\n        this.setPrefix(childPrefix);\n        const staticNode = new StaticNode(parentPrefix);\n        staticNode.staticChildren[childPrefix.charAt(0)] = this;\n        parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;\n        return staticNode;\n    }\n    getNextNode(path, pathIndex, nodeStack, paramsCount) {\n        let node = this.findStaticMatchingChild(path, pathIndex);\n        let parametricBrotherNodeIndex = 0;\n        if (node === undefined) {\n            if (this.parametricChildren.length === 0) {\n                return this.wildcardChild;\n            }\n            node = this.parametricChildren[0];\n            parametricBrotherNodeIndex = 1;\n        }\n        if (this.wildcardChild !== undefined) {\n            nodeStack.push({\n                paramsCount,\n                brotherPathIndex: pathIndex,\n                brotherNode: this.wildcardChild\n            });\n        }\n        for(let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--){\n            nodeStack.push({\n                paramsCount,\n                brotherPathIndex: pathIndex,\n                brotherNode: this.parametricChildren[i]\n            });\n        }\n        return node;\n    }\n}\nclass ParametricNode extends ParentNode {\n    constructor(regex, staticSuffix, nodePath){\n        super();\n        this._tag = \"ParametricNode\";\n        this.regex = regex;\n        this.staticSuffix = staticSuffix;\n        this.isRegex = !!regex;\n        this.nodePaths = new Set([\n            nodePath\n        ]);\n    }\n    getNextNode(path, pathIndex) {\n        return this.findStaticMatchingChild(path, pathIndex);\n    }\n}\nclass WildcardNode extends NodeBase {\n    getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {\n        return undefined;\n    }\n    constructor(...args){\n        super(...args);\n        this._tag = \"WildcardNode\";\n    }\n}\nconst assert = (condition, message)=>{\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nfunction removeDuplicateSlashes(path) {\n    return path.replace(/\\/\\/+/g, \"/\");\n}\nfunction trimLastSlash(path) {\n    if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n        return path.slice(0, -1);\n    }\n    return path;\n}\nfunction compileCreateParams(params) {\n    const len = params.length;\n    return function(paramsArray) {\n        const paramsObject = {};\n        for(let i = 0; i < len; i++){\n            paramsObject[params[i]] = paramsArray[i];\n        }\n        return paramsObject;\n    };\n}\nfunction getClosingParenthensePosition(path, idx) {\n    // `path.indexOf()` will always return the first position of the closing parenthese,\n    // but it's inefficient for grouped or wrong regexp expressions.\n    // see issues #62 and #63 for more info\n    let parentheses = 1;\n    while(idx < path.length){\n        idx++;\n        // ignore skipped chars\n        if (path[idx] === \"\\\\\") {\n            idx++;\n            continue;\n        }\n        if (path[idx] === \")\") {\n            parentheses--;\n        } else if (path[idx] === \"(\") {\n            parentheses++;\n        }\n        if (!parentheses) return idx;\n    }\n    throw new TypeError('Invalid regexp expression in \"' + path + '\"');\n}\nfunction trimRegExpStartAndEnd(regexString) {\n    // removes chars that marks start \"^\" and end \"$\" of regexp\n    if (regexString.charCodeAt(1) === 94) {\n        regexString = regexString.slice(0, 1) + regexString.slice(2);\n    }\n    if (regexString.charCodeAt(regexString.length - 2) === 36) {\n        regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);\n    }\n    return regexString;\n}\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar(highCharCode, lowCharCode) {\n    if (highCharCode === 50) {\n        if (lowCharCode === 53) return \"%\";\n        if (lowCharCode === 51) return \"#\";\n        if (lowCharCode === 52) return \"$\";\n        if (lowCharCode === 54) return \"&\";\n        if (lowCharCode === 66) return \"+\";\n        if (lowCharCode === 98) return \"+\";\n        if (lowCharCode === 67) return \",\";\n        if (lowCharCode === 99) return \",\";\n        if (lowCharCode === 70) return \"/\";\n        if (lowCharCode === 102) return \"/\";\n        return undefined;\n    }\n    if (highCharCode === 51) {\n        if (lowCharCode === 65) return \":\";\n        if (lowCharCode === 97) return \":\";\n        if (lowCharCode === 66) return \";\";\n        if (lowCharCode === 98) return \";\";\n        if (lowCharCode === 68) return \"=\";\n        if (lowCharCode === 100) return \"=\";\n        if (lowCharCode === 70) return \"?\";\n        if (lowCharCode === 102) return \"?\";\n        return undefined;\n    }\n    if (highCharCode === 52 && lowCharCode === 48) {\n        return \"@\";\n    }\n    return undefined;\n}\nfunction safeDecodeURI(path) {\n    let shouldDecode = false;\n    let shouldDecodeParam = false;\n    let querystring = \"\";\n    for(let i = 1; i < path.length; i++){\n        const charCode = path.charCodeAt(i);\n        if (charCode === 37) {\n            const highCharCode = path.charCodeAt(i + 1);\n            const lowCharCode = path.charCodeAt(i + 2);\n            if (decodeComponentChar(highCharCode, lowCharCode) === undefined) {\n                shouldDecode = true;\n            } else {\n                shouldDecodeParam = true;\n                // %25 - encoded % char. We need to encode one more time to prevent double decoding\n                if (highCharCode === 50 && lowCharCode === 53) {\n                    shouldDecode = true;\n                    path = path.slice(0, i + 1) + \"25\" + path.slice(i + 1);\n                    i += 2;\n                }\n                i += 2;\n            }\n        // Some systems do not follow RFC and separate the path and query\n        // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n        // Thus, we need to split on `;` as well as `?` and `#`.\n        } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n            querystring = path.slice(i + 1);\n            path = path.slice(0, i);\n            break;\n        }\n    }\n    const decodedPath = shouldDecode ? decodeURI(path) : path;\n    return {\n        path: decodedPath,\n        querystring,\n        shouldDecodeParam\n    };\n}\nfunction safeDecodeURIComponent(uriComponent) {\n    const startIndex = uriComponent.indexOf(\"%\");\n    if (startIndex === -1) return uriComponent;\n    let decoded = \"\";\n    let lastIndex = startIndex;\n    for(let i = startIndex; i < uriComponent.length; i++){\n        if (uriComponent.charCodeAt(i) === 37) {\n            const highCharCode = uriComponent.charCodeAt(i + 1);\n            const lowCharCode = uriComponent.charCodeAt(i + 2);\n            const decodedChar = decodeComponentChar(highCharCode, lowCharCode);\n            decoded += uriComponent.slice(lastIndex, i) + decodedChar;\n            lastIndex = i + 3;\n        }\n    }\n    return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);\n}\nconst httpMethods = [\n    \"ACL\",\n    \"BIND\",\n    \"CHECKOUT\",\n    \"CONNECT\",\n    \"COPY\",\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"LINK\",\n    \"LOCK\",\n    \"M-SEARCH\",\n    \"MERGE\",\n    \"MKACTIVITY\",\n    \"MKCALENDAR\",\n    \"MKCOL\",\n    \"MOVE\",\n    \"NOTIFY\",\n    \"OPTIONS\",\n    \"PATCH\",\n    \"POST\",\n    \"PROPFIND\",\n    \"PROPPATCH\",\n    \"PURGE\",\n    \"PUT\",\n    \"REBIND\",\n    \"REPORT\",\n    \"SEARCH\",\n    \"SOURCE\",\n    \"SUBSCRIBE\",\n    \"TRACE\",\n    \"UNBIND\",\n    \"UNLINK\",\n    \"UNLOCK\",\n    \"UNSUBSCRIBE\"\n]; //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW50ZXJuYWwvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3hDLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyx3QkFBd0I7QUFDOUIsY0FBYyxHQUNQLE1BQU1DLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLENBQUMsR0FBSyxJQUFJQyxXQUFXRCxTQUFTO0FBQzlELE1BQU1DO0lBQ0pDLFlBQVlGLFVBQVUsQ0FBQyxDQUFDLENBQUU7YUFVMUJHLFNBQVMsRUFBRTthQUNYQyxRQUFRLENBQUM7UUFWUCxJQUFJLENBQUNKLE9BQU8sR0FBRztZQUNiSyxxQkFBcUI7WUFDckJDLHdCQUF3QjtZQUN4QkMsZUFBZTtZQUNmQyxnQkFBZ0I7WUFDaEIsR0FBR1IsT0FBTztRQUNaO0lBQ0Y7SUFJQVMsR0FBR0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRTtRQUN4QixNQUFNQyxxQkFBcUJGLEtBQUtHLEtBQUssQ0FBQ2hCO1FBQ3RDLElBQUllLHNCQUFzQkEsbUJBQW1CRSxLQUFLLEtBQUtDLFdBQVc7WUFDaEVDLE9BQU9OLEtBQUtPLE1BQU0sS0FBS0wsbUJBQW1CRSxLQUFLLEdBQUdGLGtCQUFrQixDQUFDLEVBQUUsQ0FBQ0ssTUFBTSxFQUFFO1lBQ2hGLE1BQU1DLFdBQVdSLEtBQUtTLE9BQU8sQ0FBQ3RCLHVCQUF1QjtZQUNyRCxNQUFNdUIsZUFBZVYsS0FBS1MsT0FBTyxDQUFDdEIsdUJBQXVCO1lBQ3pELElBQUksQ0FBQ1csRUFBRSxDQUFDQyxRQUFRUyxVQUFVUDtZQUMxQixJQUFJLENBQUNILEVBQUUsQ0FBQ0MsUUFBUVcsY0FBY1Q7WUFDOUI7UUFDRjtRQUNBLElBQUksSUFBSSxDQUFDWixPQUFPLENBQUNNLHNCQUFzQixFQUFFO1lBQ3ZDSyxPQUFPVyx1QkFBdUJYO1FBQ2hDO1FBQ0EsSUFBSSxJQUFJLENBQUNYLE9BQU8sQ0FBQ0ssbUJBQW1CLEVBQUU7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a0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veGlubGkvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW50ZXJuYWwvcm91dGVyLmpzPzY4NTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUVMgZnJvbSBcIi4uL1F1ZXJ5U3RyaW5nLmpzXCI7XG5jb25zdCBGVUxMX1BBVEhfUkVHRVhQID0gL15odHRwcz86XFwvXFwvLio/XFwvLztcbmNvbnN0IE9QVElPTkFMX1BBUkFNX1JFR0VYUCA9IC8oXFwvOlteLygpXSo/KVxcPyhcXC8/KS87XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWFrZSA9IChvcHRpb25zID0ge30pID0+IG5ldyBSb3V0ZXJJbXBsKG9wdGlvbnMpO1xuY2xhc3MgUm91dGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVTbGFzaGVzOiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICBtYXhQYXJhbUxlbmd0aDogMTAwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH1cbiAgb3B0aW9ucztcbiAgcm91dGVzID0gW107XG4gIHRyZWVzID0ge307XG4gIG9uKG1ldGhvZCwgcGF0aCwgaGFuZGxlcikge1xuICAgIGNvbnN0IG9wdGlvbmFsUGFyYW1NYXRjaCA9IHBhdGgubWF0Y2goT1BUSU9OQUxfUEFSQU1fUkVHRVhQKTtcbiAgICBpZiAob3B0aW9uYWxQYXJhbU1hdGNoICYmIG9wdGlvbmFsUGFyYW1NYXRjaC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQocGF0aC5sZW5ndGggPT09IG9wdGlvbmFsUGFyYW1NYXRjaC5pbmRleCArIG9wdGlvbmFsUGFyYW1NYXRjaFswXS5sZW5ndGgsIFwiT3B0aW9uYWwgUGFyYW1ldGVyIG5lZWRzIHRvIGJlIHRoZSBsYXN0IHBhcmFtZXRlciBvZiB0aGUgcGF0aFwiKTtcbiAgICAgIGNvbnN0IHBhdGhGdWxsID0gcGF0aC5yZXBsYWNlKE9QVElPTkFMX1BBUkFNX1JFR0VYUCwgXCIkMSQyXCIpO1xuICAgICAgY29uc3QgcGF0aE9wdGlvbmFsID0gcGF0aC5yZXBsYWNlKE9QVElPTkFMX1BBUkFNX1JFR0VYUCwgXCIkMlwiKTtcbiAgICAgIHRoaXMub24obWV0aG9kLCBwYXRoRnVsbCwgaGFuZGxlcik7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgcGF0aE9wdGlvbmFsLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVTbGFzaGVzKSB7XG4gICAgICBwYXRoID0gcmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhwYXRoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgICBwYXRoID0gdHJpbUxhc3RTbGFzaChwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kcyA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgPyBbbWV0aG9kXSA6IG1ldGhvZDtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICB0aGlzLl9vbihtZXRob2QsIHBhdGgsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBhbGwocGF0aCwgaGFuZGxlcikge1xuICAgIHRoaXMub24oaHR0cE1ldGhvZHMsIHBhdGgsIGhhbmRsZXIpO1xuICB9XG4gIF9vbihtZXRob2QsIHBhdGgsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy50cmVlc1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudHJlZXNbbWV0aG9kXSA9IG5ldyBTdGF0aWNOb2RlKFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm4gPSBwYXRoO1xuICAgIGlmIChwYXR0ZXJuID09PSBcIipcIiAmJiB0aGlzLnRyZWVzW21ldGhvZF0ucHJlZml4Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgY3VycmVudFJvb3QgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgICB0aGlzLnRyZWVzW21ldGhvZF0gPSBuZXcgU3RhdGljTm9kZShcIlwiKTtcbiAgICAgIHRoaXMudHJlZXNbbWV0aG9kXS5zdGF0aWNDaGlsZHJlbltcIi9cIl0gPSBjdXJyZW50Um9vdDtcbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGVQYXRoSW5kZXggPSB0aGlzLnRyZWVzW21ldGhvZF0ucHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNTggJiYgcGF0dGVybi5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgLy8gSXQncyBhIGRvdWJsZSBjb2xvblxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQYXJhbWV0cmljTm9kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNTggJiYgcGF0dGVybi5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gNTg7XG4gICAgICBjb25zdCBpc1dpbGRjYXJkTm9kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNDI7XG4gICAgICBpZiAoaXNQYXJhbWV0cmljTm9kZSB8fCBpc1dpbGRjYXJkTm9kZSB8fCBpID09PSBwYXR0ZXJuLmxlbmd0aCAmJiBpICE9PSBwYXJlbnROb2RlUGF0aEluZGV4KSB7XG4gICAgICAgIGxldCBzdGF0aWNOb2RlUGF0aCA9IHBhdHRlcm4uc2xpY2UocGFyZW50Tm9kZVBhdGhJbmRleCwgaSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICBzdGF0aWNOb2RlUGF0aCA9IHN0YXRpY05vZGVQYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljTm9kZVBhdGggPSBzdGF0aWNOb2RlUGF0aC5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpO1xuICAgICAgICBzdGF0aWNOb2RlUGF0aCA9IHN0YXRpY05vZGVQYXRoLnNwbGl0KFwiJVwiKS5qb2luKFwiJTI1XCIpO1xuICAgICAgICAvLyBhZGQgdGhlIHN0YXRpYyBwYXJ0IG9mIHRoZSByb3V0ZSB0byB0aGUgdHJlZVxuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmNyZWF0ZVN0YXRpY0NoaWxkKHN0YXRpY05vZGVQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcmFtZXRyaWNOb2RlKSB7XG4gICAgICAgIGxldCBpc1JlZ2V4Tm9kZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZWdleHBzID0gW107XG4gICAgICAgIGxldCBsYXN0UGFyYW1TdGFydEluZGV4ID0gaSArIDE7XG4gICAgICAgIGZvciAobGV0IGogPSBsYXN0UGFyYW1TdGFydEluZGV4OzsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgY29uc3QgaXNSZWdleFBhcmFtID0gY2hhckNvZGUgPT09IDQwO1xuICAgICAgICAgIGNvbnN0IGlzU3RhdGljUGFydCA9IGNoYXJDb2RlID09PSA0NSB8fCBjaGFyQ29kZSA9PT0gNDY7XG4gICAgICAgICAgY29uc3QgaXNFbmRPZk5vZGUgPSBjaGFyQ29kZSA9PT0gNDcgfHwgaiA9PT0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGlzUmVnZXhQYXJhbSB8fCBpc1N0YXRpY1BhcnQgfHwgaXNFbmRPZk5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhdHRlcm4uc2xpY2UobGFzdFBhcmFtU3RhcnRJbmRleCwgaik7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICAgICAgaXNSZWdleE5vZGUgPSBpc1JlZ2V4Tm9kZSB8fCBpc1JlZ2V4UGFyYW0gfHwgaXNTdGF0aWNQYXJ0O1xuICAgICAgICAgICAgaWYgKGlzUmVnZXhQYXJhbSkge1xuICAgICAgICAgICAgICBjb25zdCBlbmRPZlJlZ2V4SW5kZXggPSBnZXRDbG9zaW5nUGFyZW50aGVuc2VQb3NpdGlvbihwYXR0ZXJuLCBqKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVnZXhTdHJpbmcgPSBwYXR0ZXJuLnNsaWNlKGosIGVuZE9mUmVnZXhJbmRleCArIDEpO1xuICAgICAgICAgICAgICByZWdleHBzLnB1c2godHJpbVJlZ0V4cFN0YXJ0QW5kRW5kKHJlZ2V4U3RyaW5nKSk7XG4gICAgICAgICAgICAgIGogPSBlbmRPZlJlZ2V4SW5kZXggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnZXhwcy5wdXNoKFwiKC4qPylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNQYXJ0U3RhcnRJbmRleCA9IGo7XG4gICAgICAgICAgICBmb3IgKDsgaiA8IHBhdHRlcm4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gNDcpIGJyZWFrO1xuICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gcGF0dGVybi5jaGFyQ29kZUF0KGogKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID09PSA1OCkgaisrO2Vsc2UgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGF0aWNQYXJ0ID0gcGF0dGVybi5zbGljZShzdGF0aWNQYXJ0U3RhcnRJbmRleCwgaik7XG4gICAgICAgICAgICBpZiAoc3RhdGljUGFydCkge1xuICAgICAgICAgICAgICBzdGF0aWNQYXJ0ID0gc3RhdGljUGFydC5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICBzdGF0aWNQYXJ0ID0gc3RhdGljUGFydC5zcGxpdChcIiVcIikuam9pbihcIiUyNVwiKTtcbiAgICAgICAgICAgICAgcmVnZXhwcy5wdXNoKGVzY2FwZVJlZ0V4cChzdGF0aWNQYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UGFyYW1TdGFydEluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICBpZiAoaXNFbmRPZk5vZGUgfHwgcGF0dGVybi5jaGFyQ29kZUF0KGopID09PSA0NyB8fCBqID09PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlUGF0dGVybiA9IGlzUmVnZXhOb2RlID8gXCIoKVwiICsgc3RhdGljUGFydCA6IHN0YXRpY1BhcnQ7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVQYXRoID0gcGF0dGVybi5zbGljZShpLCBqKTtcbiAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMCwgaSArIDEpICsgbm9kZVBhdHRlcm4gKyBwYXR0ZXJuLnNsaWNlKGopO1xuICAgICAgICAgICAgICBpICs9IG5vZGVQYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBpc1JlZ2V4Tm9kZSA/IG5ldyBSZWdFeHAoXCJeXCIgKyByZWdleHBzLmpvaW4oXCJcIikgKyBcIiRcIikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuY3JlYXRlUGFyYW1ldHJpY0NoaWxkKHJlZ2V4LCBzdGF0aWNQYXJ0LCBub2RlUGF0aCk7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGVQYXRoSW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzV2lsZGNhcmROb2RlKSB7XG4gICAgICAgIC8vIGFkZCB0aGUgd2lsZGNhcmQgcGFyYW1ldGVyXG4gICAgICAgIHBhcmFtcy5wdXNoKFwiKlwiKTtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5jcmVhdGVXaWxkY2FyZENoaWxkKCk7XG4gICAgICAgIHBhcmVudE5vZGVQYXRoSW5kZXggPSBpICsgMTtcbiAgICAgICAgaWYgKGkgIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpbGRjYXJkIG11c3QgYmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSByb3V0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIHBhdHRlcm4gPSBcIi8qXCI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXhpc3RSb3V0ZSBvZiB0aGlzLnJvdXRlcykge1xuICAgICAgaWYgKGV4aXN0Um91dGUubWV0aG9kID09PSBtZXRob2QgJiYgZXhpc3RSb3V0ZS5wYXR0ZXJuID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kICcke21ldGhvZH0nIGFscmVhZHkgZGVjbGFyZWQgZm9yIHJvdXRlICcke3BhdHRlcm59J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBwYXR0ZXJuLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFuZGxlclxuICAgIH07XG4gICAgdGhpcy5yb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgY3VycmVudE5vZGUuYWRkUm91dGUocm91dGUpO1xuICB9XG4gIGhhcyhtZXRob2QsIHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy50cmVlc1ttZXRob2RdO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljTm9kZSA9IG5vZGUuZ2V0U3RhdGljQ2hpbGQocGF0aCk7XG4gICAgaWYgKHN0YXRpY05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljTm9kZS5pc0xlYWZOb2RlO1xuICB9XG4gIGZpbmQobWV0aG9kLCBwYXRoKSB7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy50cmVlc1ttZXRob2RdO1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoMCkgIT09IDQ3KSB7XG4gICAgICAvLyA0NyBpcyAnLydcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoRlVMTF9QQVRIX1JFR0VYUCwgXCIvXCIpO1xuICAgIH1cbiAgICAvLyBUaGlzIG11c3QgYmUgcnVuIGJlZm9yZSBzYW5pdGl6ZVVybCBhcyB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gICAgLy8gLnNsaWNlUGFyYW1ldGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBzYW1lIFVSTCBzdHJpbmcgdXNlZFxuICAgIC8vIHRocm91Z2hvdXQgdGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVNsYXNoZXMpIHtcbiAgICAgIHBhdGggPSByZW1vdmVEdXBsaWNhdGVTbGFzaGVzKHBhdGgpO1xuICAgIH1cbiAgICBsZXQgc2FuaXRpemVkVXJsO1xuICAgIGxldCBxdWVyeXN0cmluZztcbiAgICBsZXQgc2hvdWxkRGVjb2RlUGFyYW07XG4gICAgdHJ5IHtcbiAgICAgIHNhbml0aXplZFVybCA9IHNhZmVEZWNvZGVVUkkocGF0aCk7XG4gICAgICBwYXRoID0gc2FuaXRpemVkVXJsLnBhdGg7XG4gICAgICBxdWVyeXN0cmluZyA9IHNhbml0aXplZFVybC5xdWVyeXN0cmluZztcbiAgICAgIHNob3VsZERlY29kZVBhcmFtID0gc2FuaXRpemVkVXJsLnNob3VsZERlY29kZVBhcmFtO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVRyYWlsaW5nU2xhc2gpIHtcbiAgICAgIHBhdGggPSB0cmltTGFzdFNsYXNoKHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5QYXRoID0gcGF0aDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNhc2VTZW5zaXRpdmUgPT09IGZhbHNlKSB7XG4gICAgICBwYXRoID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQYXJhbUxlbmd0aCA9IHRoaXMub3B0aW9ucy5tYXhQYXJhbUxlbmd0aDtcbiAgICBsZXQgcGF0aEluZGV4ID0gY3VycmVudE5vZGUucHJlZml4Lmxlbmd0aDtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBjb25zdCBwYXRoTGVuID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgYnJvdGhlcnNOb2Rlc1N0YWNrID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChwYXRoSW5kZXggPT09IHBhdGhMZW4gJiYgY3VycmVudE5vZGUuaXNMZWFmTm9kZSkge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBjdXJyZW50Tm9kZS5oYW5kbGVyU3RvcmFnZT8uZmluZCgpO1xuICAgICAgICBpZiAoaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlLmhhbmRsZXIsXG4gICAgICAgICAgICBwYXJhbXM6IGhhbmRsZS5jcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogUVMucGFyc2UocXVlcnlzdHJpbmcpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5vZGUgPSBjdXJyZW50Tm9kZS5nZXROZXh0Tm9kZShwYXRoLCBwYXRoSW5kZXgsIGJyb3RoZXJzTm9kZXNTdGFjaywgcGFyYW1zLmxlbmd0aCk7XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChicm90aGVyc05vZGVzU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBicm90aGVyTm9kZVN0YXRlID0gYnJvdGhlcnNOb2Rlc1N0YWNrLnBvcCgpO1xuICAgICAgICBwYXRoSW5kZXggPSBicm90aGVyTm9kZVN0YXRlLmJyb3RoZXJQYXRoSW5kZXg7XG4gICAgICAgIHBhcmFtcy5zcGxpY2UoYnJvdGhlck5vZGVTdGF0ZS5wYXJhbXNDb3VudCk7XG4gICAgICAgIG5vZGUgPSBicm90aGVyTm9kZVN0YXRlLmJyb3RoZXJOb2RlO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgLy8gc3RhdGljIHJvdXRlXG4gICAgICBpZiAoY3VycmVudE5vZGUuX3RhZyA9PT0gXCJTdGF0aWNOb2RlXCIpIHtcbiAgICAgICAgcGF0aEluZGV4ICs9IGN1cnJlbnROb2RlLnByZWZpeC5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnROb2RlLl90YWcgPT09IFwiV2lsZGNhcmROb2RlXCIpIHtcbiAgICAgICAgbGV0IHBhcmFtID0gb3JpZ2luUGF0aC5zbGljZShwYXRoSW5kZXgpO1xuICAgICAgICBpZiAoc2hvdWxkRGVjb2RlUGFyYW0pIHtcbiAgICAgICAgICBwYXJhbSA9IHNhZmVEZWNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgcGF0aEluZGV4ID0gcGF0aExlbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudE5vZGUuX3RhZyA9PT0gXCJQYXJhbWV0cmljTm9kZVwiKSB7XG4gICAgICAgIGxldCBwYXJhbUVuZEluZGV4ID0gb3JpZ2luUGF0aC5pbmRleE9mKFwiL1wiLCBwYXRoSW5kZXgpO1xuICAgICAgICBpZiAocGFyYW1FbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBwYXJhbUVuZEluZGV4ID0gcGF0aExlbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW0gPSBvcmlnaW5QYXRoLnNsaWNlKHBhdGhJbmRleCwgcGFyYW1FbmRJbmRleCk7XG4gICAgICAgIGlmIChzaG91bGREZWNvZGVQYXJhbSkge1xuICAgICAgICAgIHBhcmFtID0gc2FmZURlY29kZVVSSUNvbXBvbmVudChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlZ2V4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVkUGFyYW1ldGVycyA9IGN1cnJlbnROb2RlLnJlZ2V4LmV4ZWMocGFyYW0pO1xuICAgICAgICAgIGlmIChtYXRjaGVkUGFyYW1ldGVycyA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaGVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFBhcmFtID0gbWF0Y2hlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZFBhcmFtLmxlbmd0aCA+IG1heFBhcmFtTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMucHVzaChtYXRjaGVkUGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoID4gbWF4UGFyYW1MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoSW5kZXggPSBwYXJhbUVuZEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgSGFuZGxlclN0b3JhZ2Uge1xuICBoYW5kbGVycyA9IFtdO1xuICB1bmNvbnN0cmFpbmVkSGFuZGxlcjtcbiAgZmluZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmNvbnN0cmFpbmVkSGFuZGxlcjtcbiAgfVxuICBhZGQocm91dGUpIHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgcGFyYW1zOiByb3V0ZS5wYXJhbXMsXG4gICAgICBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyLFxuICAgICAgY3JlYXRlUGFyYW1zOiBjb21waWxlQ3JlYXRlUGFyYW1zKHJvdXRlLnBhcmFtcylcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB0aGlzLnVuY29uc3RyYWluZWRIYW5kbGVyID0gdGhpcy5oYW5kbGVyc1swXTtcbiAgfVxufVxuY2xhc3MgTm9kZUJhc2Uge1xuICBpc0xlYWZOb2RlID0gZmFsc2U7XG4gIHJvdXRlcztcbiAgaGFuZGxlclN0b3JhZ2U7XG4gIGFkZFJvdXRlKHJvdXRlKSB7XG4gICAgaWYgKHRoaXMucm91dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucm91dGVzID0gW3JvdXRlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhbmRsZXJTdG9yYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGFuZGxlclN0b3JhZ2UgPSBuZXcgSGFuZGxlclN0b3JhZ2UoKTtcbiAgICB9XG4gICAgdGhpcy5pc0xlYWZOb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmhhbmRsZXJTdG9yYWdlLmFkZChyb3V0ZSk7XG4gIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gIHN0YXRpY0NoaWxkcmVuID0ge307XG4gIGZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCkge1xuICAgIGNvbnN0IHN0YXRpY0NoaWxkID0gdGhpcy5zdGF0aWNDaGlsZHJlbltwYXRoLmNoYXJBdChwYXRoSW5kZXgpXTtcbiAgICBpZiAoc3RhdGljQ2hpbGQgPT09IHVuZGVmaW5lZCB8fCAhc3RhdGljQ2hpbGQubWF0Y2hQcmVmaXgocGF0aCwgcGF0aEluZGV4KSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRpY0NoaWxkO1xuICB9XG4gIGdldFN0YXRpY0NoaWxkKHBhdGgsIHBhdGhJbmRleCA9IDApIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IHBhdGhJbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0NoaWxkID0gdGhpcy5maW5kU3RhdGljTWF0Y2hpbmdDaGlsZChwYXRoLCBwYXRoSW5kZXgpO1xuICAgIGlmIChzdGF0aWNDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljQ2hpbGQuZ2V0U3RhdGljQ2hpbGQocGF0aCwgcGF0aEluZGV4ICsgc3RhdGljQ2hpbGQucHJlZml4Lmxlbmd0aCk7XG4gIH1cbiAgY3JlYXRlU3RhdGljQ2hpbGQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxldCBzdGF0aWNDaGlsZCA9IHRoaXMuc3RhdGljQ2hpbGRyZW5bcGF0aC5jaGFyQXQoMCldO1xuICAgIGlmIChzdGF0aWNDaGlsZCkge1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgZm9yICg7IGkgPCBzdGF0aWNDaGlsZC5wcmVmaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSAhPT0gc3RhdGljQ2hpbGQucHJlZml4LmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICBzdGF0aWNDaGlsZCA9IHN0YXRpY0NoaWxkLnNwbGl0KHRoaXMsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGljQ2hpbGQuY3JlYXRlU3RhdGljQ2hpbGQocGF0aC5zbGljZShpKSk7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gcGF0aC5jaGFyQXQoMCk7XG4gICAgdGhpcy5zdGF0aWNDaGlsZHJlbltsYWJlbF0gPSBuZXcgU3RhdGljTm9kZShwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNDaGlsZHJlbltsYWJlbF07XG4gIH1cbn1cbmNsYXNzIFN0YXRpY05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgX3RhZyA9IFwiU3RhdGljTm9kZVwiO1xuICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0UHJlZml4KHByZWZpeCk7XG4gIH1cbiAgcHJlZml4O1xuICBtYXRjaFByZWZpeDtcbiAgcGFyYW1ldHJpY0NoaWxkcmVuID0gW107XG4gIHdpbGRjYXJkQ2hpbGQ7XG4gIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5tYXRjaFByZWZpeCA9IChfcGF0aCwgX3BhdGhJbmRleCkgPT4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICAgIHRoaXMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbiAocGF0aCwgcGF0aEluZGV4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KHBhdGhJbmRleCArIGkpICE9PSB0aGlzLnByZWZpeC5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZ2V0UGFyYW1ldHJpY0NoaWxkKHJlZ2V4KSB7XG4gICAgaWYgKHJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmlzUmVnZXggPT09IGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gcmVnZXguc291cmNlO1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5maW5kKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5yZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZC5yZWdleC5zb3VyY2UgPT09IHNvdXJjZTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVQYXJhbWV0cmljQ2hpbGQocmVnZXgsIHN0YXRpY1N1ZmZpeCwgbm9kZVBhdGgpIHtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldFBhcmFtZXRyaWNDaGlsZChyZWdleCk7XG4gICAgaWYgKGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaWxkLm5vZGVQYXRocy5hZGQobm9kZVBhdGgpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBjaGlsZCA9IG5ldyBQYXJhbWV0cmljTm9kZShyZWdleCwgc3RhdGljU3VmZml4LCBub2RlUGF0aCk7XG4gICAgdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4uc29ydCgoY2hpbGQxLCBjaGlsZDIpID0+IHtcbiAgICAgIGlmICghY2hpbGQxLmlzUmVnZXgpIHJldHVybiAxO1xuICAgICAgaWYgKCFjaGlsZDIuaXNSZWdleCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGNoaWxkMS5zdGF0aWNTdWZmaXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgICBpZiAoY2hpbGQyLnN0YXRpY1N1ZmZpeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICBpZiAoY2hpbGQyLnN0YXRpY1N1ZmZpeC5lbmRzV2l0aChjaGlsZDEuc3RhdGljU3VmZml4KSkgcmV0dXJuIDE7XG4gICAgICBpZiAoY2hpbGQxLnN0YXRpY1N1ZmZpeC5lbmRzV2l0aChjaGlsZDIuc3RhdGljU3VmZml4KSkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIGNyZWF0ZVdpbGRjYXJkQ2hpbGQoKSB7XG4gICAgaWYgKHRoaXMud2lsZGNhcmRDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpbGRjYXJkQ2hpbGQgPSBuZXcgV2lsZGNhcmROb2RlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpbGRjYXJkQ2hpbGQ7XG4gIH1cbiAgc3BsaXQocGFyZW50Tm9kZSwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyZW50UHJlZml4ID0gdGhpcy5wcmVmaXguc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaGlsZFByZWZpeCA9IHRoaXMucHJlZml4LnNsaWNlKGxlbmd0aCk7XG4gICAgdGhpcy5zZXRQcmVmaXgoY2hpbGRQcmVmaXgpO1xuICAgIGNvbnN0IHN0YXRpY05vZGUgPSBuZXcgU3RhdGljTm9kZShwYXJlbnRQcmVmaXgpO1xuICAgIHN0YXRpY05vZGUuc3RhdGljQ2hpbGRyZW5bY2hpbGRQcmVmaXguY2hhckF0KDApXSA9IHRoaXM7XG4gICAgcGFyZW50Tm9kZS5zdGF0aWNDaGlsZHJlbltwYXJlbnRQcmVmaXguY2hhckF0KDApXSA9IHN0YXRpY05vZGU7XG4gICAgcmV0dXJuIHN0YXRpY05vZGU7XG4gIH1cbiAgZ2V0TmV4dE5vZGUocGF0aCwgcGF0aEluZGV4LCBub2RlU3RhY2ssIHBhcmFtc0NvdW50KSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCk7XG4gICAgbGV0IHBhcmFtZXRyaWNCcm90aGVyTm9kZUluZGV4ID0gMDtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbGRjYXJkQ2hpbGQ7XG4gICAgICB9XG4gICAgICBub2RlID0gdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW5bMF07XG4gICAgICBwYXJhbWV0cmljQnJvdGhlck5vZGVJbmRleCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLndpbGRjYXJkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZVN0YWNrLnB1c2goe1xuICAgICAgICBwYXJhbXNDb3VudCxcbiAgICAgICAgYnJvdGhlclBhdGhJbmRleDogcGF0aEluZGV4LFxuICAgICAgICBicm90aGVyTm9kZTogdGhpcy53aWxkY2FyZENoaWxkXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGFyYW1ldHJpY0NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gcGFyYW1ldHJpY0Jyb3RoZXJOb2RlSW5kZXg7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2goe1xuICAgICAgICBwYXJhbXNDb3VudCxcbiAgICAgICAgYnJvdGhlclBhdGhJbmRleDogcGF0aEluZGV4LFxuICAgICAgICBicm90aGVyTm9kZTogdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW5baV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuY2xhc3MgUGFyYW1ldHJpY05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgcmVnZXg7XG4gIHN0YXRpY1N1ZmZpeDtcbiAgX3RhZyA9IFwiUGFyYW1ldHJpY05vZGVcIjtcbiAgY29uc3RydWN0b3IocmVnZXgsIHN0YXRpY1N1ZmZpeCwgbm9kZVBhdGgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICB0aGlzLnN0YXRpY1N1ZmZpeCA9IHN0YXRpY1N1ZmZpeDtcbiAgICB0aGlzLmlzUmVnZXggPSAhIXJlZ2V4O1xuICAgIHRoaXMubm9kZVBhdGhzID0gbmV3IFNldChbbm9kZVBhdGhdKTtcbiAgfVxuICBpc1JlZ2V4O1xuICBub2RlUGF0aHM7XG4gIGdldE5leHROb2RlKHBhdGgsIHBhdGhJbmRleCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCk7XG4gIH1cbn1cbmNsYXNzIFdpbGRjYXJkTm9kZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgX3RhZyA9IFwiV2lsZGNhcmROb2RlXCI7XG4gIGdldE5leHROb2RlKF9wYXRoLCBfcGF0aEluZGV4LCBfbm9kZVN0YWNrLCBfcGFyYW1zQ291bnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5jb25zdCBhc3NlcnQgPSAoY29uZGl0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xufVxuZnVuY3Rpb24gdHJpbUxhc3RTbGFzaChwYXRoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3KSB7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gY29tcGlsZUNyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgbGVuID0gcGFyYW1zLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXNBcnJheSkge1xuICAgIGNvbnN0IHBhcmFtc09iamVjdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBhcmFtc09iamVjdFtwYXJhbXNbaV1dID0gcGFyYW1zQXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXNPYmplY3Q7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbG9zaW5nUGFyZW50aGVuc2VQb3NpdGlvbihwYXRoLCBpZHgpIHtcbiAgLy8gYHBhdGguaW5kZXhPZigpYCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGZpcnN0IHBvc2l0aW9uIG9mIHRoZSBjbG9zaW5nIHBhcmVudGhlc2UsXG4gIC8vIGJ1dCBpdCdzIGluZWZmaWNpZW50IGZvciBncm91cGVkIG9yIHdyb25nIHJlZ2V4cCBleHByZXNzaW9ucy5cbiAgLy8gc2VlIGlzc3VlcyAjNjIgYW5kICM2MyBmb3IgbW9yZSBpbmZvXG4gIGxldCBwYXJlbnRoZXNlcyA9IDE7XG4gIHdoaWxlIChpZHggPCBwYXRoLmxlbmd0aCkge1xuICAgIGlkeCsrO1xuICAgIC8vIGlnbm9yZSBza2lwcGVkIGNoYXJzXG4gICAgaWYgKHBhdGhbaWR4XSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGlkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXRoW2lkeF0gPT09IFwiKVwiKSB7XG4gICAgICBwYXJlbnRoZXNlcy0tO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpZHhdID09PSBcIihcIikge1xuICAgICAgcGFyZW50aGVzZXMrKztcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRoZXNlcykgcmV0dXJuIGlkeDtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHJlZ2V4cCBleHByZXNzaW9uIGluIFwiJyArIHBhdGggKyAnXCInKTtcbn1cbmZ1bmN0aW9uIHRyaW1SZWdFeHBTdGFydEFuZEVuZChyZWdleFN0cmluZykge1xuICAvLyByZW1vdmVzIGNoYXJzIHRoYXQgbWFya3Mgc3RhcnQgXCJeXCIgYW5kIGVuZCBcIiRcIiBvZiByZWdleHBcbiAgaWYgKHJlZ2V4U3RyaW5nLmNoYXJDb2RlQXQoMSkgPT09IDk0KSB7XG4gICAgcmVnZXhTdHJpbmcgPSByZWdleFN0cmluZy5zbGljZSgwLCAxKSArIHJlZ2V4U3RyaW5nLnNsaWNlKDIpO1xuICB9XG4gIGlmIChyZWdleFN0cmluZy5jaGFyQ29kZUF0KHJlZ2V4U3RyaW5nLmxlbmd0aCAtIDIpID09PSAzNikge1xuICAgIHJlZ2V4U3RyaW5nID0gcmVnZXhTdHJpbmcuc2xpY2UoMCwgcmVnZXhTdHJpbmcubGVuZ3RoIC0gMikgKyByZWdleFN0cmluZy5zbGljZShyZWdleFN0cmluZy5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gcmVnZXhTdHJpbmc7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuLy8gSXQgbXVzdCBzcG90IGFsbCB0aGUgY2hhcnMgd2hlcmUgZGVjb2RlVVJJQ29tcG9uZW50KHgpICE9PSBkZWNvZGVVUkkoeClcbi8vIFRoZSBjaGFycyBhcmU6ICMgJCAmICsgLCAvIDogOyA9ID8gQFxuZnVuY3Rpb24gZGVjb2RlQ29tcG9uZW50Q2hhcihoaWdoQ2hhckNvZGUsIGxvd0NoYXJDb2RlKSB7XG4gIGlmIChoaWdoQ2hhckNvZGUgPT09IDUwKSB7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA1MykgcmV0dXJuIFwiJVwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNTEpIHJldHVybiBcIiNcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDUyKSByZXR1cm4gXCIkXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA1NCkgcmV0dXJuIFwiJlwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNjYpIHJldHVybiBcIitcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDk4KSByZXR1cm4gXCIrXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2NykgcmV0dXJuIFwiLFwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gOTkpIHJldHVybiBcIixcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDcwKSByZXR1cm4gXCIvXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSAxMDIpIHJldHVybiBcIi9cIjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChoaWdoQ2hhckNvZGUgPT09IDUxKSB7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2NSkgcmV0dXJuIFwiOlwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gOTcpIHJldHVybiBcIjpcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDY2KSByZXR1cm4gXCI7XCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA5OCkgcmV0dXJuIFwiO1wiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNjgpIHJldHVybiBcIj1cIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDEwMCkgcmV0dXJuIFwiPVwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNzApIHJldHVybiBcIj9cIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDEwMikgcmV0dXJuIFwiP1wiO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTIgJiYgbG93Q2hhckNvZGUgPT09IDQ4KSB7XG4gICAgcmV0dXJuIFwiQFwiO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzYWZlRGVjb2RlVVJJKHBhdGgpIHtcbiAgbGV0IHNob3VsZERlY29kZSA9IGZhbHNlO1xuICBsZXQgc2hvdWxkRGVjb2RlUGFyYW0gPSBmYWxzZTtcbiAgbGV0IHF1ZXJ5c3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJDb2RlID09PSAzNykge1xuICAgICAgY29uc3QgaGlnaENoYXJDb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGNvbnN0IGxvd0NoYXJDb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkgKyAyKTtcbiAgICAgIGlmIChkZWNvZGVDb21wb25lbnRDaGFyKGhpZ2hDaGFyQ29kZSwgbG93Q2hhckNvZGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3VsZERlY29kZVBhcmFtID0gdHJ1ZTtcbiAgICAgICAgLy8gJTI1IC0gZW5jb2RlZCAlIGNoYXIuIFdlIG5lZWQgdG8gZW5jb2RlIG9uZSBtb3JlIHRpbWUgdG8gcHJldmVudCBkb3VibGUgZGVjb2RpbmdcbiAgICAgICAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTAgJiYgbG93Q2hhckNvZGUgPT09IDUzKSB7XG4gICAgICAgICAgc2hvdWxkRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpICsgMSkgKyBcIjI1XCIgKyBwYXRoLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuICAgICAgLy8gU29tZSBzeXN0ZW1zIGRvIG5vdCBmb2xsb3cgUkZDIGFuZCBzZXBhcmF0ZSB0aGUgcGF0aCBhbmQgcXVlcnlcbiAgICAgIC8vIHN0cmluZyB3aXRoIGEgYDtgIGNoYXJhY3RlciAoY29kZSA1OSksIGUuZy4gYC9mb287anNlc3Npb25pZD0xMjM0NTZgLlxuICAgICAgLy8gVGh1cywgd2UgbmVlZCB0byBzcGxpdCBvbiBgO2AgYXMgd2VsbCBhcyBgP2AgYW5kIGAjYC5cbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSA2MyB8fCBjaGFyQ29kZSA9PT0gNTkgfHwgY2hhckNvZGUgPT09IDM1KSB7XG4gICAgICBxdWVyeXN0cmluZyA9IHBhdGguc2xpY2UoaSArIDEpO1xuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjb2RlZFBhdGggPSBzaG91bGREZWNvZGUgPyBkZWNvZGVVUkkocGF0aCkgOiBwYXRoO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGRlY29kZWRQYXRoLFxuICAgIHF1ZXJ5c3RyaW5nLFxuICAgIHNob3VsZERlY29kZVBhcmFtXG4gIH07XG59XG5mdW5jdGlvbiBzYWZlRGVjb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudCkge1xuICBjb25zdCBzdGFydEluZGV4ID0gdXJpQ29tcG9uZW50LmluZGV4T2YoXCIlXCIpO1xuICBpZiAoc3RhcnRJbmRleCA9PT0gLTEpIHJldHVybiB1cmlDb21wb25lbnQ7XG4gIGxldCBkZWNvZGVkID0gXCJcIjtcbiAgbGV0IGxhc3RJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgdXJpQ29tcG9uZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgY29uc3QgaGlnaENoYXJDb2RlID0gdXJpQ29tcG9uZW50LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgY29uc3QgbG93Q2hhckNvZGUgPSB1cmlDb21wb25lbnQuY2hhckNvZGVBdChpICsgMik7XG4gICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IGRlY29kZUNvbXBvbmVudENoYXIoaGlnaENoYXJDb2RlLCBsb3dDaGFyQ29kZSk7XG4gICAgICBkZWNvZGVkICs9IHVyaUNvbXBvbmVudC5zbGljZShsYXN0SW5kZXgsIGkpICsgZGVjb2RlZENoYXI7XG4gICAgICBsYXN0SW5kZXggPSBpICsgMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVyaUNvbXBvbmVudC5zbGljZSgwLCBzdGFydEluZGV4KSArIGRlY29kZWQgKyB1cmlDb21wb25lbnQuc2xpY2UobGFzdEluZGV4KTtcbn1cbmNvbnN0IGh0dHBNZXRob2RzID0gW1wiQUNMXCIsIFwiQklORFwiLCBcIkNIRUNLT1VUXCIsIFwiQ09OTkVDVFwiLCBcIkNPUFlcIiwgXCJERUxFVEVcIiwgXCJHRVRcIiwgXCJIRUFEXCIsIFwiTElOS1wiLCBcIkxPQ0tcIiwgXCJNLVNFQVJDSFwiLCBcIk1FUkdFXCIsIFwiTUtBQ1RJVklUWVwiLCBcIk1LQ0FMRU5EQVJcIiwgXCJNS0NPTFwiLCBcIk1PVkVcIiwgXCJOT1RJRllcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQT1NUXCIsIFwiUFJPUEZJTkRcIiwgXCJQUk9QUEFUQ0hcIiwgXCJQVVJHRVwiLCBcIlBVVFwiLCBcIlJFQklORFwiLCBcIlJFUE9SVFwiLCBcIlNFQVJDSFwiLCBcIlNPVVJDRVwiLCBcIlNVQlNDUklCRVwiLCBcIlRSQUNFXCIsIFwiVU5CSU5EXCIsIFwiVU5MSU5LXCIsIFwiVU5MT0NLXCIsIFwiVU5TVUJTQ1JJQkVcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIlFTIiwiRlVMTF9QQVRIX1JFR0VYUCIsIk9QVElPTkFMX1BBUkFNX1JFR0VYUCIsIm1ha2UiLCJvcHRpb25zIiwiUm91dGVySW1wbCIsImNvbnN0cnVjdG9yIiwicm91dGVzIiwidHJlZXMiLCJpZ25vcmVUcmFpbGluZ1NsYXNoIiwiaWdub3JlRHVwbGljYXRlU2xhc2hlcyIsImNhc2VTZW5zaXRpdmUiLCJtYXhQYXJhbUxlbmd0aCIsIm9uIiwibWV0aG9kIiwicGF0aCIsImhhbmRsZXIiLCJvcHRpb25hbFBhcmFtTWF0Y2giLCJtYXRjaCIsImluZGV4IiwidW5kZWZpbmVkIiwiYXNzZXJ0IiwibGVuZ3RoIiwicGF0aEZ1bGwiLCJyZXBsYWNlIiwicGF0aE9wdGlvbmFsIiwicmVtb3ZlRHVwbGljYXRlU2xhc2hlcyIsInRyaW1MYXN0U2xhc2giLCJtZXRob2RzIiwiX29uIiwiYWxsIiwiaHR0cE1ldGhvZHMiLCJTdGF0aWNOb2RlIiwicGF0dGVybiIsInByZWZpeCIsImN1cnJlbnRSb290Iiwic3RhdGljQ2hpbGRyZW4iLCJwYXJlbnROb2RlUGF0aEluZGV4IiwiY3VycmVudE5vZGUiLCJwYXJhbXMiLCJpIiwiY2hhckNvZGVBdCIsImlzUGFyYW1ldHJpY05vZGUiLCJpc1dpbGRjYXJkTm9kZSIsInN0YXRpY05vZGVQYXRoIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInNwbGl0Iiwiam9pbiIsImNyZWF0ZVN0YXRpY0NoaWxkIiwiaXNSZWdleE5vZGUiLCJyZWdleHBzIiwibGFzdFBhcmFtU3RhcnRJbmRleCIsImoiLCJjaGFyQ29kZSIsImlzUmVnZXhQYXJhbSIsImlzU3RhdGljUGFydCIsImlzRW5kT2ZOb2RlIiwicGFyYW1OYW1lIiwicHVzaCIsImVuZE9mUmVnZXhJbmRleCIsImdldENsb3NpbmdQYXJlbnRoZW5zZVBvc2l0aW9uIiwicmVnZXhTdHJpbmciLCJ0cmltUmVnRXhwU3RhcnRBbmRFbmQiLCJzdGF0aWNQYXJ0U3RhcnRJbmRleCIsIm5leHRDaGFyQ29kZSIsInN0YXRpY1BhcnQiLCJlc2NhcGVSZWdFeHAiLCJub2RlUGF0dGVybiIsIm5vZGVQYXRoIiwicmVnZXgiLCJSZWdFeHAiLCJjcmVhdGVQYXJhbWV0cmljQ2hpbGQiLCJjcmVhdGVXaWxkY2FyZENoaWxkIiwiRXJyb3IiLCJleGlzdFJvdXRlIiwicm91dGUiLCJhZGRSb3V0ZSIsImhhcyIsIm5vZGUiLCJzdGF0aWNOb2RlIiwiZ2V0U3RhdGljQ2hpbGQiLCJpc0xlYWZOb2RlIiwiZmluZCIsInNhbml0aXplZFVybCIsInF1ZXJ5c3RyaW5nIiwic2hvdWxkRGVjb2RlUGFyYW0iLCJzYWZlRGVjb2RlVVJJIiwiZXJyb3IiLCJvcmlnaW5QYXRoIiwicGF0aEluZGV4IiwicGF0aExlbiIsImJyb3RoZXJzTm9kZXNTdGFjayIsImhhbmRsZSIsImhhbmRsZXJTdG9yYWdlIiwiY3JlYXRlUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwicGFyc2UiLCJnZXROZXh0Tm9kZSIsImJyb3RoZXJOb2RlU3RhdGUiLCJwb3AiLCJicm90aGVyUGF0aEluZGV4Iiwic3BsaWNlIiwicGFyYW1zQ291bnQiLCJicm90aGVyTm9kZSIsIl90YWciLCJwYXJhbSIsInNhZmVEZWNvZGVVUklDb21wb25lbnQiLCJwYXJhbUVuZEluZGV4IiwiaW5kZXhPZiIsIm1hdGNoZWRQYXJhbWV0ZXJzIiwiZXhlYyIsIm1hdGNoZWRQYXJhbSIsIkhhbmRsZXJTdG9yYWdlIiwidW5jb25zdHJhaW5lZEhhbmRsZXIiLCJhZGQiLCJjb21waWxlQ3JlYXRlUGFyYW1zIiwiaGFuZGxlcnMiLCJOb2RlQmFzZSIsIlBhcmVudE5vZGUiLCJmaW5kU3RhdGljTWF0Y2hpbmdDaGlsZCIsInN0YXRpY0NoaWxkIiwiY2hhckF0IiwibWF0Y2hQcmVmaXgiLCJsYWJlbCIsInBhcmFtZXRyaWNDaGlsZHJlbiIsInNldFByZWZpeCIsIl9wYXRoIiwiX3BhdGhJbmRleCIsImxlbiIsImdldFBhcmFtZXRyaWNDaGlsZCIsImNoaWxkIiwiaXNSZWdleCIsInNvdXJjZSIsInN0YXRpY1N1ZmZpeCIsIm5vZGVQYXRocyIsIlBhcmFtZXRyaWNOb2RlIiwic29ydCIsImNoaWxkMSIsImNoaWxkMiIsImVuZHNXaXRoIiwid2lsZGNhcmRDaGlsZCIsIldpbGRjYXJkTm9kZSIsInBhcmVudE5vZGUiLCJwYXJlbnRQcmVmaXgiLCJjaGlsZFByZWZpeCIsIm5vZGVTdGFjayIsInBhcmFtZXRyaWNCcm90aGVyTm9kZUluZGV4IiwiU2V0IiwiX25vZGVTdGFjayIsIl9wYXJhbXNDb3VudCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJwYXJhbXNBcnJheSIsInBhcmFtc09iamVjdCIsImlkeCIsInBhcmVudGhlc2VzIiwiVHlwZUVycm9yIiwic3RyaW5nIiwiZGVjb2RlQ29tcG9uZW50Q2hhciIsImhpZ2hDaGFyQ29kZSIsImxvd0NoYXJDb2RlIiwic2hvdWxkRGVjb2RlIiwiZGVjb2RlZFBhdGgiLCJkZWNvZGVVUkkiLCJ1cmlDb21wb25lbnQiLCJzdGFydEluZGV4IiwiZGVjb2RlZCIsImxhc3RJbmRleCIsImRlY29kZWRDaGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\n");

/***/ })

};
;